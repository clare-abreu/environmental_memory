This folder contains code for inferring fitness of mutants based on raw frequency data, and formatting these fitness inferences for plotting in the figures. The subfolder fit_lists_for_bootstrap contains code for bootstrapping standard errors, as explained below.

The code was run in the following order:

# infer_fitness.py
This code uses the raw barcode frequency data (../../data/tidy_bc_fitness_counts_freqs.csv), to infer fitness of each barcoded mutant in each environment. 

The environments are either static (Glu, Gal, Lac, H, N) or fluctuating (all combinations of static), and the fitness is calculated for the two components of the fluctuating environments separately. The data in tidy_bc_fitness_counts_freqs.csv starts at timepoint 0, which is the end of the first growth cycle in which mutants, ancestors, and neutral strains were mixed. (Timepoint -1 is not included, which is the initial frequency after mixing but before growing together.) Static environment measurements continued for five cycles, or up to timepoint 4. Fluctuating environment measurements continued for six cycles, or up to timepoint 5, to allow for equal time in both environmental components.

Static environment fitness inferences include timepoint 0, while fluctuating environment inferences typically do not and start at timepoint 1 instead. Since both inferences exclude timepoint -1, this means static inferences exclude frequency changes from the first growth cycle, while fluctuating inferences exclude the first two growth cycles. In two fluctuating environments (Glu/H and Lac/H), we included timepoint 0 and excluded timepoint 5, because the barcoded pool reached a frequency greater than 0.5 in the final timepoint (Supplementary Fig. 12). We excluded the final timepoint from the static environment H, for the same reason. Finally, in the third replicate of the Gal/Lac environment, there was no data in the final timepoint so it was excluded. These changes are denoted throughout this and the following codes as "exceptions," "rm_high_pool_frac," and "T0" or "not" ("T0" meaning timepoint 0 is included, "not" meaning it is not included).

The functions calc_fitness_MLE_naive and calc_fitness_MLE_naive_skip_zeros_static calculate fitness at each timepoint as described in the Methods section. These functions average fitness from all timepoints to get an estimate for each mutant in each condition, as well as calculating a naive standard error by minimizing the negative log likelihood across all timepoints for a given mutant in a given condition, and dividing the standard deviation by the square root of the number of timepoints. To generate an improved standard error, we calculated and saved simple estimates of fitness, without the minimization of the negative log likelihood, using the functions save_fitness and save_fitness_skip_zeros_static, for bootstrapping (sampling from fitness estimates with replacement) the minimization of the negative log likelihood with 250 trials in another piece of code (see subfolder fit_lists_for_bootstrap).

Also included in this code are the controls (shown in Supp. Fig. 8) for comparing memory in fluctuating environments to "memory" in static environments, and for confirming that memory is not an artifact of regression to the mean.

# format_data.py
This code takes output from infer_fitness.py, stored in data/ and formats it into dataframes that contain information about the mutants. This information includes the source environments where the mutants evolved and whether they are adaptive (fitness per cycle > 0.05) in this home environment. In the data plotted in the main text figures, we exclude non-adaptive mutants, as well as neutral strains that were added to the measurements in order to calculate mean population fitness, and "Alice/Bob" mutants, which are a nickname for mutants being analyzed in another upcoming study. As explained previously, "withT0" and "withoutT0" refer to whether the first timepoint is included in the fitness inferences in fluctuating environments. "Exceptions" refers to timepoints that were excluded from particular environments for the reasons explained above.

# calc_fit_stats.py
This code takes output from format_data.py stored in formatted_data/ and calculates fitness statistics of mutants, including their mean difference in fitness across pairs of static environments and their mean non-additivity and memory in fluctuating environments. 

Note that choosing which data to use as the input requires specifying variables "thr", or adaptive threshold in the home environment, and "choose", which allows for using fluctuating environment fitness inferences with or without the first timepoint (T0) included, and whether the exceptions explained above are made to exclude timepoints where the barcoded pool fraction exceeds 0.5. Here, we chose "normal" for the adaptive threshold, which defines 0.05 as adaptive, and "not_rm_high_pool_frac" for "choose," which means T0 is not included in fluctuating fitness inferences, with the exception of conditions where the pool reached a high fraction in the last timepoint. 

The variable drop_LacH refers to whether the Lac/H condition is included in the averaging over fluctuating environments to find mean non-additivity and mean memory. We always chose to set this variable to True, since rep-rep correlations of fitness and memory for this condition are poor, as explained in the manuscript and shown in Supp. Fig. 2. The variable drop_batch_fx refers to whether to exclude two additional fluctuating environments (Glu/H and Gal/Lac) in which rep-rep correlation of memory is only ~0.5. For the main text figures, we set this variable to False, but as shown in Supp. Fig. 6C, setting this variable to True does not change results and even strengthens the overall trend.

# compose_fitness_df.py
This code composes the fitness dataframe used to plot the main text figures and saves it in ../../data/fitness_df.csv. This involves selecting the data output from calc_fit_stats.py, stored in summary_data/, as well as the bootstrapped standard errors calculated in the subfolder fit_lists_for_bootstrap and stored in formatted_data.
